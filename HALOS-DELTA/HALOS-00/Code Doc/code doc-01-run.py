import ast
import re
import sys
import subprocess
from pathlib import Path
from typing import Dict, List, Optional, Tuple
import difflib
import textwrap
import pyttsx3  # For TTS functionality
import tempfile

class CodeDoctorPro:
    def __init__(self):
        # Security patterns to detect
        self.security_anti_patterns = {
            'eval': {
                'pattern': r'eval\(',
                'risk': 'Critical',
                'description': 'eval() can execute arbitrary code and is dangerous',
                'fix': 'Use ast.literal_eval() or specific parsing logic'
            },
            'pickle': {
                'pattern': r'pickle\.loads?\(',
                'risk': 'Critical',
                'description': 'Pickle can execute arbitrary code during unpickling',
                'fix': 'Use JSON or other serialization methods'
            },
            'shell_true': {
                'pattern': r'subprocess\.\w+\(.*shell\s*=\s*True',
                'risk': 'High',
                'description': 'Shell=True can enable shell injection attacks',
                'fix': 'Use shell=False with explicit command lists'
            }
        }
        
        self.test_generators = {
            'python': self.generate_python_tests,
            'solidity': self.generate_solidity_tests
        }
        
        self.taint_sources = [
            'request.GET', 'request.POST', 'request.headers',
            'os.environ', 'input()', 'sys.argv'
        ]
        
        self.secure_sinks = [
            'subprocess.call', 'eval', 'exec', 'os.system',
            'open', 'json.loads', 'pickle.loads'
        ]

    def analyze_security(self, code: str, language: str = 'python') -> Dict:
        """Enhanced security analysis with taint tracking"""
        results = {
            'security_issues': [],
            'taint_flows': []
        }
        
        # 1. Detect anti-patterns
        for name, pattern in self.security_anti_patterns.items():
            if re.search(pattern['pattern'], code):
                matches = list(re.finditer(pattern['pattern'], code))
                for match in matches:
                    line = code[:match.start()].count('\n') + 1
                    results['security_issues'].append({
                        'type': 'security',
                        'name': name,
                        'risk': pattern['risk'],
                        'description': pattern['description'],
                        'fix': pattern['fix'],
                        'line': line
                    })
        
        # 2. Taint analysis (simplified)
        if language == 'python':
            try:
                tree = ast.parse(code)
                taint_results = self._analyze_taint(tree)
                results['taint_flows'] = taint_results
            except SyntaxError:
                pass
        
        return results

    def _analyze_taint(self, tree: ast.AST) -> List[Dict]:
        """Basic taint analysis to track unsafe data flows"""
        issues = []
        
        # This would be implemented with proper data flow analysis
        # Simplified for demonstration:
        for node in ast.walk(tree):
            if isinstance(node, ast.Call):
                if isinstance(node.func, ast.Attribute):
                    func_name = f"{node.func.value.id}.{node.func.attr}"
                    if func_name in self.secure_sinks:
                        issues.append({
                            'type': 'taint_flow',
                            'sink': func_name,
                            'risk': 'Potential unsafe data flow to dangerous function',
                            'severity': 'High'
                        })
        
        return issues

    def generate_tests(self, code: str, language: str = 'python') -> str:
        """Generate test cases for the given code"""
        generator = self.test_generators.get(language)
        if generator:
            return generator(code)
        return f"# No test generator available for {language}"

    def generate_python_tests(self, code: str) -> str:
        """Generate pytest test cases for Python code"""
        test_template = textwrap.dedent('''\
        import pytest
        from your_module import *

        # Generated by CodeDoctorPro
        {test_cases}
        ''')
        
        # This would analyze the code to generate meaningful tests
        # Simplified for demonstration:
        test_cases = []
        
        # Detect functions to test
        try:
            tree = ast.parse(code)
            for node in ast.walk(tree):
                if isinstance(node, ast.FunctionDef):
                    test_case = textwrap.dedent(f'''\
                    def test_{node.name}():
                        """Test for {node.name}"""
                        # TODO: Add test logic
                        assert False, "Test not implemented"
                    ''')
                    test_cases.append(test_case)
        except SyntaxError:
            pass
        
        return test_template.format(test_cases='\n\n'.join(test_cases))

    def generate_solidity_tests(self, code: str) -> str:
        """Generate test cases for Solidity smart contracts"""
        return textwrap.dedent('''\
        // SPDX-License-Identifier: MIT
        pragma solidity ^0.8.0;

        import "forge-std/Test.sol";
        import "../YourContract.sol";

        contract YourContractTest is Test {
            YourContract public yourContract;

            function setUp() public {
                yourContract = new YourContract();
            }

            // Generated by CodeDoctorPro
            function testExample() public {
                // TODO: Add test logic
                assertTrue(false, "Test not implemented");
            }
        }
        ''')

    def apply_patches(self, file_path: str, patches: List[Dict]) -> str:
        """Apply patches to a file and return the diff"""
        with open(file_path, 'r') as f:
            original = f.read().splitlines()
        
        patched = original.copy()
        
        # Apply patches in reverse line order to preserve line numbers
        for patch in sorted(patches, key=lambda x: x['line'], reverse=True):
            if patch['action'] == 'replace':
                patched[patch['line']-1] = patch['new_content']
            elif patch['action'] == 'insert':
                patched.insert(patch['line']-1, patch['new_content'])
            elif patch['action'] == 'delete':
                del patched[patch['line']-1]
        
        diff = difflib.unified_diff(
            original,
            patched,
            fromfile=file_path,
            tofile=file_path,
            lineterm=''
        )
        
        # Write changes if confirmed
        with open(file_path, 'w') as f:
            f.write('\n'.join(patched))
        
        return '\n'.join(diff)

    def text_to_speech(self, report: str):
        """Read analysis report aloud"""
        engine = pyttsx3.init()
        engine.say("Code Doctor Pro Analysis Report")
        engine.say(report)
        engine.runAndWait()

    def analyze_file(self, file_path: str) -> Dict:
        """Full analysis of a single file"""
        with open(file_path, 'r') as f:
            code = f.read()
        
        language = self._detect_language(file_path)
        diagnosis = {
            'file': file_path,
            'language': language,
            'security': self.analyze_security(code, language),
            'tests': self.generate_tests(code, language)
        }
        
        return diagnosis

    def _detect_language(self, file_path: str) -> str:
        """Detect language from file extension"""
        ext = Path(file_path).suffix.lower()
        return {
            '.py': 'python',
            '.sol': 'solidity',
            '.js': 'javascript'
        }.get(ext, 'unknown')

def main():
    doctor = CodeDoctorPro()
    
    if len(sys.argv) > 1:
        file_path = sys.argv[1]
        results = doctor.analyze_file(file_path)
        
        print("\n🔒 Security Report:")
        for issue in results['security']['security_issues']:
            print(f"⚠️ [{issue['risk']}] {issue['description']} (line {issue['line']})")
            print(f"   Fix: {issue['fix']}")
        
        print("\n🛡️ Taint Analysis:")
        for flow in results['security']['taint_flows']:
            print(f"🚨 {flow['risk']} - flows to {flow['sink']}")
        
        print("\n🧪 Generated Tests:")
        print(results['tests'])
        
        # Generate TTS report
        if '--tts' in sys.argv:
            report = f"Found {len(results['security']['security_issues'])} security issues"
            doctor.text_to_speech(report)
        
        # Example patch application
        if '--patch' in sys.argv:
            patches = [{
                'line': 10,
                'action': 'replace',
                'new_content': '# Fixed: replaced dangerous eval()'
            }]
            diff = doctor.apply_patches(file_path, patches)
            print("\n🔧 Applied Patches:")
            print(diff)
    else:
        print("Usage: codedoctorpro.py <file> [--tts] [--patch]")

if __name__ == "__main__":
    main()